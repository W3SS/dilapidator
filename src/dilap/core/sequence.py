import dilap.topology.planargraph as pgr

#import dilap.worldly.blgsequencing as bseq

import pdb



# create methods which return various types of graphs given sequences of characters
#
# given a type of graph to return and a character sequence
#   create the graph instance, affect its topology using the sequence, and return it



def gseq(seq):
    
    pdb.set_trace()




# FROM WORLDLY.PARTITIONGRAPH
def graph(self):
    seq = self.sequence[:]
    scnt = len(seq)
    sx = 0
    while sx < scnt:
        c = seq[sx]
        if c in self.grammer:
            ex = db.seqread(seq,sx)
            self.grammer[c](self,seq[sx+2:ex])
        else:ex = sx+1
        sx = ex
    for vx in range(self.vcnt):self.vve(vx)
    return self

# TERRAIN
def ter_checkseq(fp,h,seq,show = False):
    print('check-tseq:',seq)
    t = tmesh()
    #t.looptree = dtr.tree()
    t.root = t.al(fp,None)

    tip = t.root
    tip = t.grow(tip,1,2)
    tip = t.grow(tip,1,8)
    tip = t.grow(tip,1,2)
    tip = t.grow(tip,2,4)

    if show:
        t.plot()
        t.plotxy()
        plt.show()
    return t

###############################################################################


# FROM ROADGRAPH
'''#
import dilap.core.base as db
import dilap.core.context as cx
import dilap.modeling.model as dmo
import dilap.modeling.factory as dfa

from dilap.geometry.vec3 import vec3
from dilap.geometry.quat import quat
import dilap.geometry.tools as gtl
import dilap.geometry.polymath as pym

import dilap.worldly.treeskin as ltr
import dilap.worldly.building as blg
import dilap.worldly.blgsequencing as bseq
import dilap.worldly.partitiongraph as ptg

import dilap.core.plotting as dtl
import matplotlib.pyplot as plt

import math,numpy,random,pdb

###############################################################################

def checkseq(pg,fp,seq,show = False):
    print('check-pseq:',seq)
    easement = 2

    def trimtofp(p1,p2,r = 5):
        ips = pym.sintbxyp(p1,p2,fp)
        if len(ips) > 0:
            for ip in ips:
                if ip.isnear(p1):continue
                p2 = p1.lerp(ip,1-r/p1.d(ip))
        return p2

    def seed(rg,ss):
        print('SEED',ss)
        exp = fp[-1].lerp(fp[0],0.5)
        exn = vec3(0,0,1).crs(fp[-1].tov(fp[0])).nrm()
        ex1 = exp.cp()
        ex2 = ex1.cp().trn(exn.cp().uscl(easement))
        i1 = rg.av(p = ex1,l = 0)
        i2,r1 = rg.mev(i1,{'p':ex2,'l':0},{})
        return [i2]

    def grow(rg,ss):
        print('GROW',ss)
        tip = nvs[-1]
        tv = rg.vs[tip]
        avs = [rg.vs[k] for k in rg.orings[tip]]
        if len(avs) == 1:
            op = tv[1]['p']
            nptn = avs[0][1]['p'].tov(op).nrm().uscl(100)
            np = op.cp().trn(nptn)
            np = trimtofp(op,np,easement+10)
            nv,nr = rg.mev(tip,{'p':np,'l':0},{})
        return [nv]

    def loop(rg,ss):
        print('LOOP',ss)

    grammer = {
        'S':seed,
        'G':grow,
        'L':loop,
            }

    scnt = len(seq)
    sx = 0
    while sx < scnt:
        c = seq[sx]
        if c in grammer:
            ex = db.seqread(seq,sx)
            nvs = grammer[c](pg,seq[sx+2:ex])
        else:ex = sx+1
        sx = ex
    if show:
        ax = pg.plot()
        ax = dtl.plot_polygon(fp,ax,col = 'r')
        plt.show()
    return pg

###############################################################################

'''#

###############################################################################


#from worldly.terrain
###############################################################################
### sequences
###############################################################################

# create a topography for use within a vertex 
def cartographer(g,subseq):
    ss = subseq.split(',')
    tv = g.vs[int(ss[0])]
    fp = [p.cp().ztrn(float(ss[2])) for p in tv[1]['fp']]
    h = float(ss[1])
    tseq = ss[3]
    tm = ter.checkseq(fp,h,tseq,False)
    tv[1]['info']['terrainmesh'] = tm
    return g

# given a "natural" space, 
# create a sequence which generates a "developed" space
# 
# this must include laying of roads through an iterative process
# in the spaces adjacent to the roads, produce hubs of buildings with parking
# if necessary, lay roads which exit the space
#   this means laying a road seam on the boundary
#   this should include the vertex where this road should find
#       another metropolitan area
def metropolis(g,subseq):
    irx,rseq,bseq = subseq.split(',')
    irx = int(irx)
    iv = g.vs[irx]
    print('METROPOLIS!',subseq)

    # the goal is to contrive a sequence representing an urban area
    #   surrounded by rural areas so that it can be connected to other areas
    #   found on a continent including other areas generated by this method
    # this means splitting a region based on geometric information...

    easement = 2

    iv[1]['type'] = ['developed']
    fp = iv[1]['fp']

    rg = pgr.graph()
    rg = rdg.checkseq(rg,fp,rseq,True)

    rgpy = pym.pgtopy(rg,1)

    rgpyi = list(rgpy[0])
    #rgpyi = pym.ebixy(fp,rgpy[0])
    if pym.bnrm(rgpyi).z < 0:
        rgpyi.reverse()
        rgpy = (tuple(rgpyi),rgpy[1])

    #easement_py = pym.ebdxy(fp,rgpyi)
    easement_py = fp

    #rgpyi = pym.ebixy(fp,rgpy[0])

    print('eas',easement_py)

    ax = rg.plot()
    ax = dtl.plot_polygon(easement_py,ax,col = 'b',lw = 2)
    #ax = dtl.plot_polygon(rgpyi,ax,col = 'g',lw = 2)
    #ax = dtl.plot_polygon_full(rgpy,ax,col = 'r',lw = 2)
    plt.show()
    
    new = g.sv(irx,easement_py,rgpyi)
    g.vs[new][1]['type'] = ['corridor']



    '''#
    mseq = subseq+','
    mseq += 'R<0,natural>'
    mseq += 'S<0,0.5,0.5,0,1,root>'
    mseq += 'S<1,0.5,0.5,1,0,root>'
    mseq += 'S<0,0.5,0.5,1,0,root>'
    mseq += 'E<0,1>E<1,2>E<2,3>E<3,0>'
    mseq += 'R<2,developed>'

    ptg.checkseq(g.vs[irx][1]['fp'],20,mseq,True,grammer = g.grammer)

    seq = subseq+','+mseq
    ptg.insert(g,seq)
    '''#



